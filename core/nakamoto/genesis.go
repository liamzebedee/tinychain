package nakamoto

import (
	"fmt"
	"math/big"
)

// The Nakamoto consensus configuration, pertaining to difficulty readjustment, genesis block, and block size.
type ConsensusConfig struct {
	// The length of an epoch.
	EpochLengthBlocks uint64 `json:"epoch_length_blocks"`

	// The target block production rate in terms of 1 epoch.
	TargetEpochLengthMillis uint64 `json:"target_epoch_length_millis"`

	// Genesis difficulty target.
	GenesisDifficulty big.Int `json:"genesis_difficulty"`

	// The genesis parent block hash.
	GenesisParentBlockHash [32]byte `json:"genesis_block_hash"`

	// Maximum block size.
	MaxBlockSizeBytes uint64 `json:"max_block_size_bytes"`
}

// Builds the raw genesis block from the consensus configuration.
func GetRawGenesisBlockFromConfig(consensus ConsensusConfig) RawBlock {
	block := RawBlock{
		// Special case: The genesis block has a parent we don't know the preimage for.
		ParentHash:             consensus.GenesisParentBlockHash,
		ParentTotalWork:        [32]byte{},
		Difficulty:             BigIntToBytes32(consensus.GenesisDifficulty),
		Timestamp:              0,
		NumTransactions:        0,
		TransactionsMerkleRoot: [32]byte{},
		Nonce:                  [32]byte{},
		Graffiti:               [32]byte{0xca, 0xfe, 0xba, 0xbe, 0xde, 0xca, 0xfb, 0xad, 0xde, 0xad, 0xbe, 0xef}, // 0x cafebabe decafbad deadbeef
		Transactions: []RawTransaction{
			{
				FromPubkey: [65]byte{0x04, 0xd0, 0xe7, 0x0c, 0xe1, 0xed, 0x48, 0x3e, 0x2f, 0x32, 0xad, 0x55, 0x11, 0x53, 0xa5, 0x36, 0x3f, 0xa6, 0xc8, 0x2f, 0xd5, 0xea, 0x0c, 0xd9, 0x5b, 0xf8, 0x0e, 0xae, 0xb3, 0x44, 0x15, 0xcb, 0x8d, 0x45, 0xc3, 0x93, 0x1f, 0xcc, 0x49, 0xed, 0x44, 0x4b, 0xe5, 0x44, 0x0f, 0x1d, 0x52, 0x23, 0x4a, 0x7e, 0xb2, 0xbd, 0x9d, 0xc3, 0x7a, 0x40, 0x90, 0x69, 0x79, 0xa5, 0x2f, 0xa0, 0x72, 0xe5, 0xb4},
				ToPubkey:   [65]byte{0x04, 0xd0, 0xe7, 0x0c, 0xe1, 0xed, 0x48, 0x3e, 0x2f, 0x32, 0xad, 0x55, 0x11, 0x53, 0xa5, 0x36, 0x3f, 0xa6, 0xc8, 0x2f, 0xd5, 0xea, 0x0c, 0xd9, 0x5b, 0xf8, 0x0e, 0xae, 0xb3, 0x44, 0x15, 0xcb, 0x8d, 0x45, 0xc3, 0x93, 0x1f, 0xcc, 0x49, 0xed, 0x44, 0x4b, 0xe5, 0x44, 0x0f, 0x1d, 0x52, 0x23, 0x4a, 0x7e, 0xb2, 0xbd, 0x9d, 0xc3, 0x7a, 0x40, 0x90, 0x69, 0x79, 0xa5, 0x2f, 0xa0, 0x72, 0xe5, 0xb4},
				Sig:        [64]byte{0xb3, 0x4c, 0x36, 0x1d, 0xb2, 0xbe, 0x89, 0x48, 0xfb, 0xd6, 0x61, 0x9e, 0xa5, 0xeb, 0xe2, 0x7b, 0x90, 0xae, 0x8d, 0x5a, 0xca, 0xa6, 0x94, 0xc2, 0x1f, 0x11, 0x81, 0x7e, 0x16, 0x98, 0x17, 0x41, 0xeb, 0x6a, 0xe8, 0xc4, 0xbf, 0x48, 0xe3, 0x13, 0x99, 0x81, 0x0e, 0xec, 0xb9, 0x62, 0x69, 0x8d, 0x8d, 0xb1, 0x15, 0x3b, 0xfb, 0x0d, 0x67, 0x6c, 0xa8, 0x6e, 0x52, 0x55, 0x1e, 0xf4, 0x27, 0x8d},
				Amount:     50,
				Fee:        0,
				Nonce:      0,
			},
		},
	}

	// Mine the block.
	solution, err := SolvePOW(block, *new(big.Int), consensus.GenesisDifficulty, 100)
	if err != nil {
		panic(err)
	}
	block.SetNonce(solution)

	// Sanity-check: verify the block.
	if !VerifyPOW(block.Hash(), consensus.GenesisDifficulty) {
		panic("Genesis block POW solution is invalid.")
	}

	// Calculate work.
	work := CalculateWork(Bytes32ToBigInt(block.Hash()))

	fmt.Printf("Genesis block hash=%x work=%s\n", block.Hash(), work.String())

	return block
}
